A compiled language is **a programming language that is converted into machine code so that the processor can execute it**. The compiled languages are usually compiled, not interpreted.

A **compiled language** is a [[Programming Languages|language]] whose [[Implementation|implementation]] are typically [[Compiler|compilers]] (translators that generate [[Machine Code|machine code]] from [source code](https://en.wikipedia.org/wiki/Source_code "Source code")), and not [[Interpreter|interpreters]] (step-by-step executors of [source code](https://en.wikipedia.org/wiki/Source_code "Source code"), where no pre-runtime translation takes place).

The term is somewhat vague. In principle, any language can be implemented with a compiler or with an interpreter. A combination of both solutions is also common: a compiler can translate the source code into some intermediate form (often called [p-code](https://en.wikipedia.org/wiki/Byte_code "Byte code") or [bytecode](https://en.wikipedia.org/wiki/Bytecode "Bytecode")), which is then passed to an interpreter which executes it.

## Advantages and disadvantages

Programs compiled into native code at compile time tend to be faster than those translated at runtime due to the translation process's overhead. Newer technologies such as [just-in-time compilation](https://en.wikipedia.org/wiki/Just-in-time_compilation "Just-in-time compilation"), and general improvements in the translation process are starting to narrow this gap, though. Mixed solutions using bytecode tend toward intermediate efficiency.

[Low-level programming languages](https://en.wikipedia.org/wiki/Low-level_programming_language "Low-level programming language") are typically compiled, especially when efficiency is the main concern, rather than [cross-platform](https://en.wikipedia.org/wiki/Cross-platform "Cross-platform") support. For such languages, there are more one-to-one correspondences between the programmed code and the hardware operations performed by [machine code](https://en.wikipedia.org/wiki/Machine_code "Machine code"), making it easier for programmers to control the use of [central processing unit](https://en.wikipedia.org/wiki/Central_processing_unit "Central processing unit") (CPU) and [memory](https://en.wikipedia.org/wiki/Computer_memory "Computer memory") in fine detail.

With some effort, it is always possible to write compilers even for traditionally [interpreted languages](https://en.wikipedia.org/wiki/Interpreted_language "Interpreted language"). For example, [Common Lisp](https://en.wikipedia.org/wiki/Common_Lisp "Common Lisp") can be compiled to Java bytecode (then interpreted by the [Java virtual machine](https://en.wikipedia.org/wiki/Java_virtual_machine "Java virtual machine")), C code (then compiled to native machine code), or directly to native code. Programming languages that support multiple compiling targets give developers more control to choose either execution speed or cross-platform compatibility or usage.